name: Release

on:
  push:
    tags:
      - "v*.*.*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Semver tag to release (e.g. v1.2.2)"
        required: true
        type: string

permissions:
  contents: write

env:
  CARGO_TERM_COLOR: always
  CARGO_INCREMENTAL: 0
  CARGO_REGISTRIES_CRATES_IO_PROTOCOL: sparse

concurrency:
  group: release-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  meta:
    name: Validate Tag and Changelog
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      tag: ${{ steps.meta.outputs.tag }}
      version: ${{ steps.meta.outputs.version }}

    steps:
      - name: Checkout
        uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608
        with:
          fetch-depth: 0

      - name: Resolve release tag
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            tag="${{ github.event.inputs.tag }}"
          else
            tag="${GITHUB_REF_NAME}"
          fi

          if [[ ! "$tag" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Tag '$tag' must match vMAJOR.MINOR.PATCH" >&2
            exit 1
          fi

          version="${tag#v}"
          echo "tag=$tag" >> "$GITHUB_OUTPUT"
          echo "version=$version" >> "$GITHUB_OUTPUT"

      - name: Validate tag exists in repository
        shell: bash
        run: |
          set -euo pipefail
          tag="${{ steps.meta.outputs.tag }}"
          git fetch --tags --force
          if ! git rev-parse --verify "refs/tags/$tag" >/dev/null 2>&1; then
            echo "Tag '$tag' does not exist in repository history" >&2
            exit 1
          fi

      - name: Validate package version matches tag
        shell: bash
        run: |
          set -euo pipefail
          expected_version="${{ steps.meta.outputs.version }}"
          package_version="$(awk '
            $0 ~ /^\[package\]/ { in_package=1; next }
            in_package && $0 ~ /^\[/ { in_package=0 }
            in_package && $0 ~ /^version = / {
              gsub(/version = \"|\"/, "", $0)
              print $0
              exit
            }
          ' Cargo.toml)"

          if [[ -z "$package_version" ]]; then
            echo "Failed to read package version from Cargo.toml" >&2
            exit 1
          fi

          if [[ "$package_version" != "$expected_version" ]]; then
            echo "Tag version ($expected_version) does not match Cargo.toml version ($package_version)" >&2
            exit 1
          fi

      - name: Validate changelog entry exists and is non-empty
        shell: bash
        run: |
          set -euo pipefail
          version="${{ steps.meta.outputs.version }}"

          awk -v version="$version" '
            $0 ~ "^## \\[" version "\\]" {in_section=1; found=1; next}
            in_section && $0 ~ "^## \\[" {exit}
            in_section {print}
            END {
              if (!found) exit 2
            }
          ' CHANGELOG.md > release_notes.md || {
            code="$?"
            if [[ "$code" -eq 2 ]]; then
              echo "No CHANGELOG.md section found for version $version" >&2
            fi
            exit "$code"
          }

          if [[ ! -s release_notes.md ]]; then
            echo "Release notes section for $version is empty" >&2
            exit 1
          fi

  verify_release:
    name: Verify Release Build
    needs: meta
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout tag
        uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608
        with:
          ref: refs/tags/${{ needs.meta.outputs.tag }}

      - name: Install pinned Rust toolchain
        shell: bash
        run: |
          set -euo pipefail
          rustup toolchain install 1.93.0 --profile minimal --component clippy
          rustup default 1.93.0

      - name: cargo fetch
        run: cargo fetch --locked

      - name: cargo check
        run: cargo check --all-targets --all-features --locked

      - name: cargo clippy
        run: cargo clippy --all-targets --all-features --locked -- -D warnings

      - name: cargo test
        run: cargo test --all-targets --all-features --locked

  draft_release:
    name: Create Draft GitHub Release
    needs: [meta, verify_release]
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout tag
        uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608
        with:
          ref: refs/tags/${{ needs.meta.outputs.tag }}

      - name: Build release notes from changelog
        shell: bash
        run: |
          set -euo pipefail
          version="${{ needs.meta.outputs.version }}"

          awk -v version="$version" '
            $0 ~ "^## \\[" version "\\]" {in_section=1; found=1; next}
            in_section && $0 ~ "^## \\[" {exit}
            in_section {print}
            END {
              if (!found) exit 2
            }
          ' CHANGELOG.md > release_notes.md

      - name: Create or update draft release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          tag="${{ needs.meta.outputs.tag }}"
          title="Rustnake $tag"

          if gh release view "$tag" >/dev/null 2>&1; then
            gh release edit "$tag" --title "$title" --notes-file release_notes.md
          else
            gh release create "$tag" --verify-tag --title "$title" --notes-file release_notes.md --draft
          fi

  binaries:
    name: Build & Upload (${{ matrix.os }})
    needs: [meta, draft_release]
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        os:
          - ubuntu-latest
          - macos-14
          - windows-latest

    steps:
      - name: Checkout tag
        uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608
        with:
          ref: refs/tags/${{ needs.meta.outputs.tag }}

      - name: Install pinned Rust toolchain
        shell: bash
        run: |
          set -euo pipefail
          rustup toolchain install 1.93.0 --profile minimal
          rustup default 1.93.0

      - name: Build release binary
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${RUNNER_OS}" == "macOS" ]]; then
            rustup target add aarch64-apple-darwin x86_64-apple-darwin
            cargo build --release --locked --target aarch64-apple-darwin
            cargo build --release --locked --target x86_64-apple-darwin
            lipo -create \
              -output target/release/rustnake-universal2 \
              target/aarch64-apple-darwin/release/rustnake \
              target/x86_64-apple-darwin/release/rustnake
          else
            cargo build --release --locked
          fi

      - name: Sign and notarize macOS binary
        if: ${{ runner.os == 'macOS' }}
        shell: bash
        env:
          MACOS_CERTIFICATE_P12_BASE64: ${{ secrets.MACOS_CERTIFICATE_P12_BASE64 }}
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
          APPLE_NOTARY_KEY_ID: ${{ secrets.APPLE_NOTARY_KEY_ID }}
          APPLE_NOTARY_ISSUER_ID: ${{ secrets.APPLE_NOTARY_ISSUER_ID }}
          APPLE_NOTARY_PRIVATE_KEY_P8_BASE64: ${{ secrets.APPLE_NOTARY_PRIVATE_KEY_P8_BASE64 }}
        run: |
          set -euo pipefail

          for required in \
            MACOS_CERTIFICATE_P12_BASE64 \
            MACOS_CERTIFICATE_PASSWORD \
            APPLE_NOTARY_KEY_ID \
            APPLE_NOTARY_ISSUER_ID \
            APPLE_NOTARY_PRIVATE_KEY_P8_BASE64; do
            if [[ -z "${!required:-}" ]]; then
              echo "Missing required secret: $required" >&2
              exit 1
            fi
          done

          decode_base64() {
            local input="$1"
            local output="$2"
            if printf '%s' "$input" | base64 --decode >"$output" 2>/dev/null; then
              return 0
            fi
            if printf '%s' "$input" | base64 -d >"$output" 2>/dev/null; then
              return 0
            fi
            printf '%s' "$input" | base64 -D >"$output"
          }

          BINARY_PATH="target/release/rustnake-universal2"
          CERT_PATH="$RUNNER_TEMP/rustnake-signing-cert.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/rustnake-signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -hex 16)"
          NOTARY_KEY_PATH="$RUNNER_TEMP/AuthKey_${APPLE_NOTARY_KEY_ID}.p8"
          ZIP_PATH="$RUNNER_TEMP/rustnake-macos-universal2.zip"

          decode_base64 "$MACOS_CERTIFICATE_P12_BASE64" "$CERT_PATH"
          decode_base64 "$APPLE_NOTARY_PRIVATE_KEY_P8_BASE64" "$NOTARY_KEY_PATH"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security default-keychain -d user -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security import "$CERT_PATH" \
            -k "$KEYCHAIN_PATH" \
            -P "$MACOS_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security \
            -T /usr/bin/xcrun
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          IDENTITY="$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | awk -F '\"' '/Developer ID Application/ {print $2; exit}')"
          if [[ -z "$IDENTITY" ]]; then
            echo "No Developer ID Application identity found in imported certificate." >&2
            exit 1
          fi

          codesign --force --options runtime --timestamp --sign "$IDENTITY" "$BINARY_PATH"
          codesign --verify --verbose=2 "$BINARY_PATH"

          ditto -c -k --keepParent "$BINARY_PATH" "$ZIP_PATH"
          xcrun notarytool submit "$ZIP_PATH" \
            --key "$NOTARY_KEY_PATH" \
            --key-id "$APPLE_NOTARY_KEY_ID" \
            --issuer "$APPLE_NOTARY_ISSUER_ID" \
            --wait

          xcrun stapler staple -v "$BINARY_PATH"
          spctl --assess --type execute --verbose=4 "$BINARY_PATH"
          rm -f "$CERT_PATH" "$NOTARY_KEY_PATH" "$ZIP_PATH"

      - name: Sign Windows binary (Authenticode)
        if: ${{ runner.os == 'Windows' }}
        shell: pwsh
        env:
          WINDOWS_CERTIFICATE_PFX_BASE64: ${{ secrets.WINDOWS_CERTIFICATE_PFX_BASE64 }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        run: |
          $ErrorActionPreference = "Stop"

          if ([string]::IsNullOrWhiteSpace($env:WINDOWS_CERTIFICATE_PFX_BASE64)) {
            throw "Missing required secret: WINDOWS_CERTIFICATE_PFX_BASE64"
          }
          if ([string]::IsNullOrWhiteSpace($env:WINDOWS_CERTIFICATE_PASSWORD)) {
            throw "Missing required secret: WINDOWS_CERTIFICATE_PASSWORD"
          }

          $certPath = Join-Path $env:RUNNER_TEMP "rustnake-signing-cert.pfx"
          [System.IO.File]::WriteAllBytes(
            $certPath,
            [System.Convert]::FromBase64String($env:WINDOWS_CERTIFICATE_PFX_BASE64)
          )

          $signtoolCommand = Get-Command signtool.exe -ErrorAction SilentlyContinue
          if ($null -ne $signtoolCommand) {
            $signtool = $signtoolCommand.Source
          } else {
            $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin" -Filter signtool.exe -Recurse |
              Sort-Object FullName -Descending |
              Select-Object -First 1 -ExpandProperty FullName
          }
          if ([string]::IsNullOrWhiteSpace($signtool)) {
            throw "signtool.exe not found on runner"
          }

          & $signtool sign `
            /fd SHA256 `
            /td SHA256 `
            /tr "http://timestamp.digicert.com" `
            /f $certPath `
            /p $env:WINDOWS_CERTIFICATE_PASSWORD `
            "target/release/rustnake.exe"
          Remove-Item -Path $certPath -Force

      - name: Verify Windows Authenticode signature
        if: ${{ runner.os == 'Windows' }}
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $signature = Get-AuthenticodeSignature "target/release/rustnake.exe"
          if ($signature.Status -ne "Valid") {
            throw "Authenticode signature is invalid: $($signature.Status)"
          }
          Write-Host "Authenticode signature is valid."

      - name: Package asset and checksum
        id: package
        shell: bash
        run: |
          set -euo pipefail
          source="target/release/rustnake"
          asset_name="rustnake-linux-x86_64"
          if [[ "${RUNNER_OS}" == "Windows" ]]; then
            source="target/release/rustnake.exe"
            asset_name="rustnake-windows-x86_64.exe"
          elif [[ "${RUNNER_OS}" == "macOS" ]]; then
            source="target/release/rustnake-universal2"
            asset_name="rustnake-macos-universal2"
          fi

          if [[ ! -f "$source" ]]; then
            echo "Missing build artifact: $source" >&2
            exit 1
          fi

          asset_path="$RUNNER_TEMP/$asset_name"
          cp "$source" "$asset_path"

          checksum_path="$RUNNER_TEMP/$asset_name.sha256"
          if command -v sha256sum >/dev/null 2>&1; then
            sha256sum "$asset_path" > "$checksum_path"
          else
            shasum -a 256 "$asset_path" > "$checksum_path"
          fi

          echo "asset_name=$asset_name" >> "$GITHUB_OUTPUT"
          echo "asset_path=$asset_path" >> "$GITHUB_OUTPUT"
          echo "checksum_path=$checksum_path" >> "$GITHUB_OUTPUT"

      - name: Upload asset and checksum to release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          gh release upload "${{ needs.meta.outputs.tag }}" \
            "${{ steps.package.outputs.asset_path }}#${{ steps.package.outputs.asset_name }}" \
            "${{ steps.package.outputs.checksum_path }}#${{ steps.package.outputs.asset_name }}.sha256" \
            --clobber

  publish_crate:
    name: Publish to crates.io
    needs: [meta, verify_release]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: crates-io-publish
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout tag
        uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608
        with:
          ref: refs/tags/${{ needs.meta.outputs.tag }}

      - name: Install pinned Rust toolchain
        shell: bash
        run: |
          set -euo pipefail
          rustup toolchain install 1.93.0 --profile minimal
          rustup default 1.93.0

      - name: cargo fetch
        run: cargo fetch --locked

      - name: cargo package
        run: cargo package --locked

      - name: Detect existing crates.io version
        id: check_version
        shell: bash
        run: |
          set -euo pipefail
          version="${{ needs.meta.outputs.version }}"
          if curl -fsSL "https://crates.io/api/v1/crates/rustnake/${version}" >/dev/null 2>&1; then
            echo "already_published=true" >> "$GITHUB_OUTPUT"
          else
            echo "already_published=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Authenticate with crates.io (Trusted Publisher)
        if: steps.check_version.outputs.already_published == 'false'
        id: auth
        uses: rust-lang/crates-io-auth-action@63a7064947ceca9989005e118db3a5fecdc9259f

      - name: Validate trusted publisher token
        if: steps.check_version.outputs.already_published == 'false'
        shell: bash
        env:
          CARGO_REGISTRY_TOKEN: ${{ steps.auth.outputs.token }}
        run: |
          set -euo pipefail
          if [[ -z "${CARGO_REGISTRY_TOKEN:-}" ]]; then
            echo "Trusted Publisher token was not provided by crates-io-auth-action." >&2
            echo "Verify crates.io Trusted Publisher settings for owner/repo/workflow/environment." >&2
            exit 1
          fi

      - name: Publish crate (idempotent)
        if: steps.check_version.outputs.already_published == 'false'
        shell: bash
        env:
          CARGO_REGISTRY_TOKEN: ${{ steps.auth.outputs.token }}
        run: |
          set +e
          output="$(cargo publish --locked 2>&1)"
          code="$?"
          set -e
          echo "$output"

          if [[ "$code" -eq 0 ]]; then
            exit 0
          fi

          if echo "$output" | grep -Eqi "already (uploaded|published|exists)"; then
            echo "Version appears to be already published; treating as success."
            exit 0
          fi

          if curl -fsSL "https://crates.io/api/v1/crates/rustnake/${{ needs.meta.outputs.version }}" >/dev/null 2>&1; then
            echo "Version is present on crates.io after failed publish attempt; treating as success."
            exit 0
          fi

          exit "$code"

      - name: Skip publish (already published)
        if: steps.check_version.outputs.already_published == 'true'
        run: echo "rustnake ${{ needs.meta.outputs.version }} already exists on crates.io; skipping publish"

  publish_release:
    name: Publish GitHub Release
    needs: [meta, binaries, publish_crate]
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout tag
        uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608
        with:
          ref: refs/tags/${{ needs.meta.outputs.tag }}

      - name: Build release notes from changelog
        shell: bash
        run: |
          set -euo pipefail
          version="${{ needs.meta.outputs.version }}"
          awk -v version="$version" '
            $0 ~ "^## \\[" version "\\]" {in_section=1; found=1; next}
            in_section && $0 ~ "^## \\[" {exit}
            in_section {print}
            END { if (!found) exit 2 }
          ' CHANGELOG.md > release_notes.md

      - name: Publish release (self-healing)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          tag="${{ needs.meta.outputs.tag }}"
          title="Rustnake $tag"

          if ! gh release view "$tag" >/dev/null 2>&1; then
            gh release create "$tag" --verify-tag --title "$title" --notes-file release_notes.md
            exit 0
          fi

          draft_state="$(gh release view "$tag" --json isDraft --jq '.isDraft')"
          if [[ "$draft_state" == "true" ]]; then
            gh release edit "$tag" --draft=false --title "$title" --notes-file release_notes.md
          else
            gh release edit "$tag" --title "$title" --notes-file release_notes.md
          fi
